import os
import platform
import shutil
from itertools import combinations

import matplotlib as mpl
# import torch
# torch.backends.cudnn.enabled = False
# torch._dynamo.config.suppress_errors = True
import matplotlib.pyplot as plt
import numpy as np
from ase.io import read, write
from ase.optimize import BFGS
from ase.visualize import view
from ase.visualize.plot import plot_atoms
from matplotlib.colors import LinearSegmentedColormap
from scipy import stats

from config import molecules_data
from utils import delete_atom_by_idx, rotate_bond_transform, calculate_formation_energy, calculate_element_mu, \
    determine_target_element

# Set global font properties for all plots
mpl.rcParams['font.family'] = 'Times New Roman'
mpl.rcParams['font.size'] = 12


mpl.rcParams['axes.titlesize'] = 16  # Plot titles
mpl.rcParams['axes.labelsize'] = 14  # Axis labels
mpl.rcParams['xtick.labelsize'] = 12  # X-axis tick labels
mpl.rcParams['ytick.labelsize'] = 12  # Y-axis tick labels
mpl.rcParams['legend.fontsize'] = 12  # Legend text
mpl.rcParams['figure.titlesize'] = 18  # Figure titles


def save_structure_image(atoms, filepath, title="Structure", show_atom_idx=True):
    """Save an image of the atomic structure using ASE's plot_atoms"""
    try:
        fig, ax = plt.subplots(figsize=(8, 8))
        plot_atoms(atoms, ax, rotation=('0x,0y,0z'))
        ax.set_title(title)
        plt.savefig(filepath, dpi=150, bbox_inches='tight')
        plt.close(fig)
    except Exception as e:
        print(f"  Warning: Could not generate image: {e}")
        # Close figure to avoid memory leaks
        plt.close('all')


def read_bonds_from_mol(filepath):
    """Read bond information from MOL file. Returns list of (atom1, atom2, bond_type) tuples (0-indexed)."""
    bonds = []
    try:
        with open(filepath, 'r') as f:
            lines = f.readlines()
        if len(lines) < 4:
            return None
        counts_line = lines[3]
        try:
            n_atoms = int(counts_line[0:3])
            n_bonds = int(counts_line[3:6])
        except:
            return None
        bond_start = 4 + n_atoms
        for i in range(n_bonds):
            if bond_start + i >= len(lines):
                break
            bond_line = lines[bond_start + i]
            if bond_line.startswith('M  END'):
                break
            try:
                atom1 = int(bond_line[0:3]) - 1
                atom2 = int(bond_line[3:6]) - 1
                bond_type = int(bond_line[6:9])
                bonds.append((atom1, atom2, bond_type))
            except:
                continue
        return bonds
    except:
        return None


def write_mol_with_bonds(atoms, filepath, original_bonds=None):
    """Write MOL file with preserved bond information."""
    positions = atoms.positions
    symbols = atoms.get_chemical_symbols()

    if original_bonds is not None:
        bonds = []
        for atom1, atom2, bond_type in original_bonds:
            if atom1 < len(atoms) and atom2 < len(atoms):
                bonds.append((atom1 + 1, atom2 + 1, bond_type))
    else:
        # Fallback: distance-based
        bonds = []
        for i in range(len(atoms)):
            for j in range(i+1, len(atoms)):
                dist = np.linalg.norm(positions[i] - positions[j])
                symbol_i, symbol_j = symbols[i], symbols[j]
                bond_type = None
                if symbol_i == 'C' and symbol_j == 'C':
                    if dist < 1.50:
                        bond_type = 2
                    elif dist < 1.60:
                        bond_type = 1
                elif (symbol_i == 'C' and symbol_j == 'H') or (symbol_i == 'H' and symbol_j == 'C'):
                    if dist < 1.15:
                        bond_type = 1
                elif dist < 1.8:
                    bond_type = 1
                if bond_type:
                    bonds.append((i+1, j+1, bond_type))

    with open(filepath, 'w') as f:
        f.write("\n  Generated by map.py\n\n")
        f.write(f"{len(atoms):3d}{len(bonds):3d}  0  0  0  0  0  0  0  0999 V2000\n")
        for pos, symbol in zip(positions, symbols):
            f.write(f"{pos[0]:10.4f}{pos[1]:10.4f}{pos[2]:10.4f} {symbol:<3s} 0  0  0  0  0  0  0  0  0  0  0  0\n")
        for i, j, bond_type in bonds:
            f.write(f"{i:3d}{j:3d}{bond_type:3d}  0  0  0  0\n")
        f.write("M  END\n")


def save_structure_file(atoms, xyz_path, mol_path, original_bonds=None):
    """Save structure in both XYZ and MOL formats with bond preservation."""
    # Save XYZ
    write(xyz_path, atoms)
    # Save MOL with bonds
    write_mol_with_bonds(atoms, mol_path, original_bonds=original_bonds)


def setup_structure(molecule_name):
    """Set up and relax the initial structure"""
    # Get parameters from config
    mol_filename = molecules_data[molecule_name]["path"]
    cell = molecules_data[molecule_name]["cell"]

    # Read molecule and center it in the cell
    atoms = read(mol_filename)
    positions = atoms.get_positions()
    center_of_mass = np.mean(positions, axis=0)
    translation = np.array([cell / 2] * 3) - center_of_mass
    positions = [list(np.array(pos) + translation) for pos in positions]
    atoms.set_positions(positions)
    atoms.set_cell([cell] * 3)
    atoms.set_pbc(True)

    # Read and store original bond information
    original_bonds = None
    if mol_filename.endswith('.mol'):
        original_bonds = read_bonds_from_mol(mol_filename)
        if original_bonds:
            print(f"Loaded {len(original_bonds)} bonds from input")
            atoms.info['original_bonds'] = original_bonds

    # Set up calculator
    atoms.set_calculator(calc)

    # Perform initial relaxation
    print("Relaxing base structure...")
    optimizer = BFGS(atoms)
    optimizer.run(fmax=0.1)

    # Get base energy
    base_relaxed = atoms.copy()
    base_relaxed.calc = calc
    base_energy = base_relaxed.get_potential_energy()
    print(f"Base structure energy: {base_energy:.3f} eV")

    return base_relaxed, base_energy


def analyze_vacancies(target_element, base_relaxed, base_energy, molecule_name, show_atom_idx=True, excluded_atoms=[], atom_idx_fontsize=8):
    """Analyze single vacancy formation energies"""
    print("\n=== Running Vacancy Analysis ===\n")
    results_dir = f"vacancy_map_{molecule_name}_cell_size_{int(base_relaxed.get_cell()[0][0])}"
    os.makedirs(results_dir, exist_ok=True)

    # Create subdirectories for structures and images
    structures_xyz_dir = os.path.join(results_dir, "relaxed_structures_xyz")
    structures_mol_dir = os.path.join(results_dir, "relaxed_structures_mol")
    images_dir = os.path.join(results_dir, "structure_images")
    os.makedirs(structures_xyz_dir, exist_ok=True)
    os.makedirs(structures_mol_dir, exist_ok=True)
    os.makedirs(images_dir, exist_ok=True)

    # Copy input file to results directory
    input_file = molecules_data[molecule_name]["path"]
    shutil.copy(input_file, os.path.join(results_dir, f"input_{os.path.basename(input_file)}"))

    # Initialize lists to store results
    formation_energies = []
    atom_indices = []

    # Loop through each atom
    for atom_idx in range(len(base_relaxed)):
        # Skip non-carbon atoms
        if base_relaxed[atom_idx].symbol != target_element or atom_idx in excluded_atoms:
            continue

        print(f"Processing atom {atom_idx} of {len(base_relaxed)} (symbol: {base_relaxed[atom_idx].symbol})")
        atom_indices.append(atom_idx)

        try:
            # Create a vacancy by removing this atom - always start from the base relaxed structure
            vacancy_atoms = delete_atom_by_idx(base_relaxed.copy(), atom_idx)

            # Set up calculator for vacancy structure
            vacancy_atoms.set_calculator(calc)

            # Relax the vacancy structure
            print(f"  Relaxing vacancy structure...")
            optimizer = BFGS(vacancy_atoms)
            optimizer.run(fmax=0.05)

            # Calculate formation energy
            formation_energy = calculate_formation_energy(base_relaxed, vacancy_atoms, calc, element_mu)

            formation_energies.append(formation_energy)
            print(f"  Atom {atom_idx} formation energy: {formation_energy:.3f} eV")

            # Save relaxed structure and image
            xyz_file = os.path.join(structures_xyz_dir, f"vacancy_atom_{atom_idx}.xyz")
            mol_file = os.path.join(structures_mol_dir, f"vacancy_atom_{atom_idx}.mol")
            image_file = os.path.join(images_dir, f"vacancy_atom_{atom_idx}.png")

            # Adjust bonds for removed atom
            original_bonds = base_relaxed.info.get('original_bonds', None)
            adjusted_bonds = None
            if original_bonds:
                adjusted_bonds = []
                for a1, a2, btype in original_bonds:
                    if a1 == atom_idx or a2 == atom_idx:
                        continue
                    new_a1 = a1 if a1 < atom_idx else a1 - 1
                    new_a2 = a2 if a2 < atom_idx else a2 - 1
                    adjusted_bonds.append((new_a1, new_a2, btype))

            save_structure_file(vacancy_atoms, xyz_file, mol_file, original_bonds=adjusted_bonds)
            save_structure_image(vacancy_atoms, image_file,
                               title=f"Vacancy at atom {atom_idx}\nE_form = {formation_energy:.3f} eV",
                               show_atom_idx=show_atom_idx)
            print(f"  Saved XYZ: {xyz_file}")
            print(f"  Saved MOL: {mol_file}")

        except Exception as e:
            print(f"  Error processing atom {atom_idx}: {e}")
            formation_energies.append(None)

    # Create output files and visualizations
    _process_vacancy_results(results_dir, base_relaxed, atom_indices, formation_energies, molecule_name, show_atom_idx, atom_idx_fontsize)

    return atom_indices, formation_energies


def analyze_divacancies(target_element, base_relaxed, base_energy, molecule_name, max_distance=1.5, show_atom_idx=True, excluded_atoms=[], atom_idx_fontsize=8):
    """Analyze divacancy formation energies"""
    print("\n=== Running Divacancy Analysis ===\n")
    results_dir = f"divacancy_map_{molecule_name}_cell_size_{int(base_relaxed.get_cell()[0][0])}"
    os.makedirs(results_dir, exist_ok=True)

    # Create subdirectories for structures and images
    structures_xyz_dir = os.path.join(results_dir, "relaxed_structures_xyz")
    structures_mol_dir = os.path.join(results_dir, "relaxed_structures_mol")
    images_dir = os.path.join(results_dir, "structure_images")
    os.makedirs(structures_xyz_dir, exist_ok=True)
    os.makedirs(structures_mol_dir, exist_ok=True)
    os.makedirs(images_dir, exist_ok=True)

    # Copy input file to results directory
    input_file = molecules_data[molecule_name]["path"]
    shutil.copy(input_file, os.path.join(results_dir, f"input_{os.path.basename(input_file)}"))

    # Initialize lists to store results
    formation_energies = []
    divacancy_pairs = []

    # Find all carbon atoms
    carbon_indices = [i for i, atom in enumerate(base_relaxed) if atom.symbol == target_element and i not in excluded_atoms]

    # Create a list of potential divacancy pairs (filter by bond distance)
    potential_pairs = []
    for idx1, idx2 in combinations(carbon_indices, 2):
        distance = base_relaxed.get_distance(idx1, idx2)
        if distance <= max_distance:
            potential_pairs.append((idx1, idx2))

    print(f"Found {len(potential_pairs)} potential divacancy pairs within {max_distance} A")

    # Loop through each pair
    for pair_idx, (atom_idx1, atom_idx2) in enumerate(potential_pairs):
        print(f"Processing divacancy pair {pair_idx + 1}/{len(potential_pairs)}: atoms {atom_idx1} and {atom_idx2}")
        divacancy_pairs.append((atom_idx1, atom_idx2))

        try:
            # Create a divacancy by removing these atoms - always start from the base relaxed structure
            divacancy_atoms = delete_atom_by_idx(base_relaxed.copy(), [atom_idx1, atom_idx2])

            # Set up calculator for divacancy structure
            divacancy_atoms.set_calculator(calc)

            # Relax the divacancy structure
            print(f"  Relaxing divacancy structure...")
            optimizer = BFGS(divacancy_atoms)
            optimizer.run(fmax=0.05)

            # Get divacancy energy
            divacancy_energy = divacancy_atoms.get_potential_energy()

            # Calculate formation energy
            mu_C = base_energy / len(base_relaxed)  # Chemical potential of carbon
            formation_energy = divacancy_energy - (len(divacancy_atoms) * mu_C)

            formation_energies.append(formation_energy)
            print(f"  Divacancy {atom_idx1}-{atom_idx2} formation energy: {formation_energy:.3f} eV")

            # Save relaxed structure and image
            xyz_file = os.path.join(structures_xyz_dir, f"divacancy_atoms_{atom_idx1}_{atom_idx2}.xyz")
            mol_file = os.path.join(structures_mol_dir, f"divacancy_atoms_{atom_idx1}_{atom_idx2}.mol")
            image_file = os.path.join(images_dir, f"divacancy_atoms_{atom_idx1}_{atom_idx2}.png")

            # Adjust bonds for two removed atoms
            original_bonds = base_relaxed.info.get('original_bonds', None)
            adjusted_bonds = None
            if original_bonds:
                adjusted_bonds = []
                removed = sorted([atom_idx1, atom_idx2])
                for a1, a2, btype in original_bonds:
                    if a1 in removed or a2 in removed:
                        continue
                    new_a1 = a1 - sum(1 for r in removed if r < a1)
                    new_a2 = a2 - sum(1 for r in removed if r < a2)
                    adjusted_bonds.append((new_a1, new_a2, btype))

            save_structure_file(divacancy_atoms, xyz_file, mol_file, original_bonds=adjusted_bonds)
            save_structure_image(divacancy_atoms, image_file,
                               title=f"Divacancy at atoms {atom_idx1}-{atom_idx2}\nE_form = {formation_energy:.3f} eV",
                               show_atom_idx=show_atom_idx)
            print(f"  Saved XYZ: {xyz_file}")
            print(f"  Saved MOL: {mol_file}")
            print(f"  Saved image to {image_file}")

        except Exception as e:
            print(f"  Error processing divacancy {atom_idx1}-{atom_idx2}: {e}")
            formation_energies.append(None)

    # Create output files and visualizations
    _process_divacancy_results(results_dir, base_relaxed, divacancy_pairs, formation_energies, molecule_name,
                               carbon_indices, show_atom_idx, atom_idx_fontsize)

    return divacancy_pairs, formation_energies


def analyze_stone_wales(target_element, base_relaxed, base_energy, molecule_name, max_distance=1.8, show_atom_idx=True, excluded_atoms=[], atom_idx_fontsize=8):
    """Analyze Stone-Wales transformation formation energies"""
    print("\n=== Running Stone-Wales Analysis ===\n")
    results_dir = f"stw_map_{molecule_name}_cell_size_{int(base_relaxed.get_cell()[0][0])}"
    os.makedirs(results_dir, exist_ok=True)

    # Create subdirectories for structures and images
    structures_xyz_dir = os.path.join(results_dir, "relaxed_structures_xyz")
    structures_mol_dir = os.path.join(results_dir, "relaxed_structures_mol")
    images_dir = os.path.join(results_dir, "structure_images")
    os.makedirs(structures_xyz_dir, exist_ok=True)
    os.makedirs(structures_mol_dir, exist_ok=True)
    os.makedirs(images_dir, exist_ok=True)

    # Copy input file to results directory
    input_file = molecules_data[molecule_name]["path"]
    shutil.copy(input_file, os.path.join(results_dir, f"input_{os.path.basename(input_file)}"))

    # Initialize lists to store results
    formation_energies = []
    bond_pairs = []

    # Find all carbon atoms
    carbon_indices = [i for i, atom in enumerate(base_relaxed) if atom.symbol == target_element and i not in excluded_atoms]

    # Create a list of potential bond pairs for rotation (filter by bond distance)
    potential_pairs = []
    for idx1, idx2 in combinations(carbon_indices, 2):
        distance = base_relaxed.get_distance(idx1, idx2)
        if distance <= max_distance:
            potential_pairs.append((idx1, idx2))

    print(f"Found {len(potential_pairs)} potential bonds within {max_distance} A")

    # Loop through each bond pair
    for pair_idx, (atom_idx1, atom_idx2) in enumerate(potential_pairs):
        print(f"Processing Stone-Wales bond {pair_idx + 1}/{len(potential_pairs)}: atoms {atom_idx1} and {atom_idx2}")
        bond_pairs.append((atom_idx1, atom_idx2))

        try:
            # Create a Stone-Wales defect by rotating the bond - always start from the base relaxed structure
            stw_atoms = base_relaxed.copy()

            # Apply the bond rotation transformation (90 degrees by default)
            rotation_transform = rotate_bond_transform(atom_idx1, atom_idx2, angle_degrees=90)
            stw_atoms = rotation_transform(stw_atoms)

            # Set up calculator for STW structure
            stw_atoms.set_calculator(calc)

            # Relax the STW structure
            print(f"  Relaxing Stone-Wales structure...")
            optimizer = BFGS(stw_atoms)
            optimizer.run(fmax=0.05)

            # Get STW energy
            stw_energy = stw_atoms.get_potential_energy()

            # Calculate formation energy (difference from base)
            formation_energy = stw_energy - base_energy

            formation_energies.append(formation_energy)
            print(f"  Stone-Wales {atom_idx1}-{atom_idx2} formation energy: {formation_energy:.3f} eV")

            # Save relaxed structure and image
            xyz_file = os.path.join(structures_xyz_dir, f"stw_bond_{atom_idx1}_{atom_idx2}.xyz")
            mol_file = os.path.join(structures_mol_dir, f"stw_bond_{atom_idx1}_{atom_idx2}.mol")
            image_file = os.path.join(images_dir, f"stw_bond_{atom_idx1}_{atom_idx2}.png")

            # Stone-Wales: no atoms removed, use original bonds
            original_bonds = base_relaxed.info.get('original_bonds', None)

            save_structure_file(stw_atoms, xyz_file, mol_file, original_bonds=original_bonds)
            save_structure_image(stw_atoms, image_file,
                               title=f"Stone-Wales defect at bond {atom_idx1}-{atom_idx2}\nE_form = {formation_energy:.3f} eV",
                               show_atom_idx=show_atom_idx)
            print(f"  Saved XYZ: {xyz_file}")
            print(f"  Saved MOL: {mol_file}")
            print(f"  Saved image to {image_file}")

        except Exception as e:
            print(f"  Error processing Stone-Wales {atom_idx1}-{atom_idx2}: {e}")
            formation_energies.append(None)

    # Create output files and visualizations
    _process_stw_results(results_dir, base_relaxed, bond_pairs, formation_energies, molecule_name, carbon_indices,
                         show_atom_idx, atom_idx_fontsize)

    return bond_pairs, formation_energies


def _process_vacancy_results(results_dir, base_relaxed, atom_indices, formation_energies, molecule_name,
                             show_atom_idx=True, atom_idx_fontsize=8):
    """Process and visualize vacancy results"""
    # Create a dictionary mapping atom indices to formation energies
    energy_map = {idx: energy for idx, energy in zip(atom_indices, formation_energies)}

    # Save formation energies with atom indices
    np.savez(os.path.join(results_dir, "formation_energies.npz"),
             indices=np.array(atom_indices),
             energies=np.array(formation_energies))

    # Write energy map to text file for easy reference
    with open(os.path.join(results_dir, "energy_map.txt"), 'w') as f:
        f.write("Atom_Index Formation_Energy(eV)\n")
        for idx, energy in zip(atom_indices, formation_energies):
            if energy is not None:
                f.write(f"{idx} {energy:.3f}\n")
            else:
                f.write(f"{idx} None\n")

    # Filter out None values for visualization and analysis
    valid_data = [(idx, energy) for idx, energy in zip(atom_indices, formation_energies) if energy is not None]
    if valid_data:
        valid_atom_idx, valid_energies = zip(*valid_data)

        # Calculate statistics
        min_energy = min(valid_energies)
        max_energy = max(valid_energies)
        min_idx = valid_atom_idx[valid_energies.index(min_energy)]
        max_idx = valid_atom_idx[valid_energies.index(max_energy)]
        avg_energy = np.mean(valid_energies)
        std_energy = np.std(valid_energies)

        # Create a custom colormap (red = high energy, blue = low energy)
        cmap = LinearSegmentedColormap.from_list("formation_energy",
                                                 ["blue", "green", "yellow", "red"])

        # Plot the structure with atoms colored by formation energy
        fig, ax = plt.subplots(figsize=(12, 10))

        # First, draw connections from vacancy sites to their neighbors
        max_bond_distance = 1.8  # Standard C-C bond distance threshold
        for idx in atom_indices:
            if idx in energy_map and energy_map[idx] is not None:
                # Find neighboring atoms within bonding distance
                pos_vacancy = base_relaxed.positions[idx]

                # Normalize energy for coloring
                norm_energy = (energy_map[idx] - min_energy) / (
                            max_energy - min_energy) if max_energy > min_energy else 0.5
                color = cmap(norm_energy)

                # Draw lines to all neighboring atoms
                for neighbor_idx, neighbor_atom in enumerate(base_relaxed):
                    if neighbor_idx != idx:
                        distance = base_relaxed.get_distance(idx, neighbor_idx)
                        if distance <= max_bond_distance:
                            pos_neighbor = base_relaxed.positions[neighbor_idx]
                            ax.plot([pos_vacancy[0], pos_neighbor[0]],
                                   [pos_vacancy[1], pos_neighbor[1]],
                                   color=color, linewidth=2.5, alpha=0.7, zorder=5)

        # Plot atoms colored by formation energy
        for i, atom in enumerate(base_relaxed):
            if i in energy_map and energy_map[i] is not None:
                # Normalize energy for coloring
                norm_energy = (energy_map[i] - min_energy) / (
                            max_energy - min_energy) if max_energy > min_energy else 0.5
                color = cmap(norm_energy)
            else:
                # Gray for non-carbon atoms or failed calculations
                color = 'gray'

            # Hydrogen atoms should be smaller
            marker_size = 50 if atom.symbol == 'H' else 100
            ax.scatter(atom.position[0], atom.position[1], c=color, s=marker_size,
                       edgecolors='black', linewidths=1, zorder=10)

            # Add atom index for reference if enabled
            if show_atom_idx:
                ax.text(atom.position[0], atom.position[1], str(i), fontsize=atom_idx_fontsize, zorder=15)

        # Create colorbar
        sm = plt.cm.ScalarMappable(cmap=cmap, norm=plt.Normalize(min_energy, max_energy))
        sm.set_array([])
        cbar = plt.colorbar(sm, ax=ax)
        cbar.set_label('Formation Energy (eV)')

        # Set plot properties
        ax.set_aspect('equal')
        ax.set_title(f'Vacancy Formation Energy Map - {molecule_name}')
        ax.set_xlabel('X (A)')
        ax.set_ylabel('Y (A)')

        # Save the plot
        plt.savefig(os.path.join(results_dir, "formation_energy_map.png"), dpi=300, bbox_inches='tight')
        plt.close()

        # Create Gaussian distribution plot and save to file
        fig2, ax2 = plt.subplots(figsize=(10, 6))

        # Plot histogram of formation energies
        hist, bins, _ = ax2.hist(valid_energies, bins=20, density=True, alpha=0.6, color='skyblue')

        # Plot Gaussian fit
        x = np.linspace(min_energy - 0.5, max_energy + 0.5, 1000)
        gaussian = stats.norm.pdf(x, avg_energy, std_energy)
        ax2.plot(x, gaussian, 'r-', linewidth=2, label=f'Gaussian Fit\nμ={avg_energy:.3f} eV\nσ={std_energy:.3f} eV')

        # Add lines for mean and ±1 std dev
        ax2.axvline(avg_energy, color='k', linestyle='--', alpha=0.5, label='Mean')
        ax2.axvline(avg_energy + std_energy, color='k', linestyle=':', alpha=0.5, label='+1σ')
        ax2.axvline(avg_energy - std_energy, color='k', linestyle=':', alpha=0.5, label='-1σ')

        # Set plot properties
        ax2.set_xlabel('Formation Energy (eV)')
        ax2.set_ylabel('Probability Density')
        ax2.set_title(f'Vacancy Formation Energy Distribution - {molecule_name}')
        ax2.legend()
        ax2.grid(alpha=0.3)

        # Save the distribution plot
        plt.savefig(os.path.join(results_dir, "energy_distribution.png"), dpi=300, bbox_inches='tight')
        plt.close()

        # Save distribution data for MATLAB
        with open(os.path.join(results_dir, "energy_distribution.txt"), 'w') as f:
            f.write("# Vacancy Formation Energy Distribution\n")
            f.write("# Mean: {:.6f} eV\n".format(avg_energy))
            f.write("# Std Dev: {:.6f} eV\n".format(std_energy))
            f.write("# Min: {:.6f} eV (atom {}) \n".format(min_energy, min_idx))
            f.write("# Max: {:.6f} eV (atom {}) \n".format(max_energy, max_idx))
            f.write("# Format: energy_value probability_density\n")
            for i in range(len(x)):
                f.write("{:.6f} {:.6f}\n".format(x[i], gaussian[i]))

        # Write summary file with statistics
        with open(os.path.join(results_dir, "summary.txt"), 'w') as f:
            f.write(f"Vacancy Formation Energy Analysis for {molecule_name}\n")
            f.write(f"----------------------------------------\n")
            f.write(f"Total carbon atoms analyzed: {len(atom_indices)}\n")
            f.write(f"Valid calculations: {len(valid_energies)}\n")
            f.write(f"Minimum formation energy: {min_energy:.3f} eV at atom index {min_idx}\n")
            f.write(f"Maximum formation energy: {max_energy:.3f} eV at atom index {max_idx}\n")
            f.write(f"Average formation energy: {avg_energy:.3f} eV\n")
            f.write(f"Standard deviation: {std_energy:.3f} eV\n")

            # Sort atoms by formation energy
            sorted_data = sorted(valid_data, key=lambda x: x[1])

            # List top 5 lowest formation energy sites
            f.write(f"\nTop 5 lowest formation energy sites (easiest to remove):\n")
            for i in range(min(5, len(sorted_data))):
                idx, energy = sorted_data[i]
                f.write(f"  Atom {idx}: {energy:.3f} eV\n")

            # List top 5 highest formation energy sites
            f.write(f"\nTop 5 highest formation energy sites (hardest to remove):\n")
            for i in range(min(5, len(sorted_data))):
                idx, energy = sorted_data[-(i + 1)]
                f.write(f"  Atom {idx}: {energy:.3f} eV\n")

            f.write(f"----------------------------------------\n")
    else:
        print("No valid vacancy calculations were completed.")


def _process_divacancy_results(results_dir, base_relaxed, divacancy_pairs, formation_energies, molecule_name,
                               carbon_indices, show_atom_idx=True, atom_idx_fontsize=8):
    """Process and visualize divacancy results"""
    # Create a dictionary mapping divacancy pairs to formation energies
    energy_map = {pair: energy for pair, energy in zip(divacancy_pairs, formation_energies)}

    # Save formation energies with divacancy pairs
    np.savez(os.path.join(results_dir, "divacancy_energies.npz"),
             pairs=np.array(divacancy_pairs),
             energies=np.array(formation_energies))

    # Write energy map to text file for easy reference
    with open(os.path.join(results_dir, "energy_map.txt"), 'w') as f:
        f.write("Atom1_Index Atom2_Index Distance(A) Formation_Energy(eV)\n")
        for (idx1, idx2), energy in zip(divacancy_pairs, formation_energies):
            distance = base_relaxed.get_distance(idx1, idx2)
            if energy is not None:
                f.write(f"{idx1} {idx2} {distance:.3f} {energy:.3f}\n")
            else:
                f.write(f"{idx1} {idx2} {distance:.3f} None\n")

    # Filter out None values for visualization and analysis
    valid_data = [(pair, energy) for pair, energy in zip(divacancy_pairs, formation_energies) if energy is not None]
    if valid_data:
        valid_pairs, valid_energies = zip(*valid_data)

        # Calculate statistics
        min_energy = min(valid_energies)
        max_energy = max(valid_energies)
        min_pair = valid_pairs[valid_energies.index(min_energy)]
        max_pair = valid_pairs[valid_energies.index(max_energy)]
        avg_energy = np.mean(valid_energies)
        std_energy = np.std(valid_energies)

        # Create a custom colormap for edges (red = high energy, blue = low energy)
        cmap = LinearSegmentedColormap.from_list("formation_energy",
                                                 ["blue", "green", "yellow", "red"])

        # Plot the structure with divacancy pairs colored by formation energy
        fig, ax = plt.subplots(figsize=(14, 12))

        # Plot all atoms first as gray circles
        for i, atom in enumerate(base_relaxed):
            # Hydrogen atoms should be smaller
            marker_size = 50 if atom.symbol == 'H' else 100
            ax.scatter(atom.position[0], atom.position[1], c='lightgray', s=marker_size,
                       edgecolors='black', linewidths=1)
            # Add atom index for reference if enabled
            if show_atom_idx:
                ax.text(atom.position[0], atom.position[1], str(i), fontsize=atom_idx_fontsize)

        # Plot the divacancy pairs as colored lines
        for (idx1, idx2), energy in energy_map.items():
            if energy is not None:
                # Normalize energy for coloring
                norm_energy = (energy - min_energy) / (max_energy - min_energy) if max_energy > min_energy else 0.5
                color = cmap(norm_energy)

                # Get atom positions
                pos1 = base_relaxed.positions[idx1]
                pos2 = base_relaxed.positions[idx2]

                # Draw line between atoms
                ax.plot([pos1[0], pos2[0]], [pos1[1], pos2[1]], color=color, linewidth=2.5, alpha=0.7)

                # Mark the pair atoms with larger markers
                ax.scatter([pos1[0], pos2[0]], [pos1[1], pos2[1]], c=color, s=150,
                           edgecolors='black', linewidths=1.5, zorder=10)

        # Create colorbar
        sm = plt.cm.ScalarMappable(cmap=cmap, norm=plt.Normalize(min_energy, max_energy))
        sm.set_array([])
        cbar = plt.colorbar(sm, ax=ax)
        cbar.set_label('Formation Energy (eV)')

        # Set plot properties
        ax.set_aspect('equal')
        ax.set_title(f'Divacancy Formation Energy Map - {molecule_name}')
        ax.set_xlabel('X (A)')
        ax.set_ylabel('Y (A)')

        # Save the plot
        plt.savefig(os.path.join(results_dir, "divacancy_energy_map.png"), dpi=300, bbox_inches='tight')
        plt.close()

        # Create another visualization showing pairs with lowest energies
        fig2, ax2 = plt.subplots(figsize=(14, 12))

        # Plot all atoms first as gray circles
        for i, atom in enumerate(base_relaxed):
            # Hydrogen atoms should be smaller
            marker_size = 50 if atom.symbol == 'H' else 100
            ax2.scatter(atom.position[0], atom.position[1], c='lightgray', s=marker_size,
                        edgecolors='black', linewidths=1)
            # Add atom index for reference if enabled
            if show_atom_idx:
                ax2.text(atom.position[0], atom.position[1], str(i), fontsize=atom_idx_fontsize)

        # Sort divacancies by formation energy
        sorted_data = sorted(valid_data, key=lambda x: x[1])

        # Plot only the top 10 lowest formation energy divacancies
        top_n = min(10, len(sorted_data))
        for i in range(top_n):
            (idx1, idx2), energy = sorted_data[i]

            # Get atom positions
            pos1 = base_relaxed.positions[idx1]
            pos2 = base_relaxed.positions[idx2]

            # Draw line between atoms with label
            line = ax2.plot([pos1[0], pos2[0]], [pos1[1], pos2[1]],
                            linewidth=3, label=f"{idx1}-{idx2}: {energy:.3f} eV")

            # Mark the pair atoms with larger markers of same color
            color = line[0].get_color()
            ax2.scatter([pos1[0], pos2[0]], [pos1[1], pos2[1]], c=color, s=150,
                        edgecolors='black', linewidths=1.5, zorder=10)

            # Add rank number at midpoint
            mid_x = (pos1[0] + pos2[0]) / 2
            mid_y = (pos1[1] + pos2[1]) / 2
            ax2.text(mid_x, mid_y, f"#{i + 1}", fontsize=12,
                     ha='center', va='center',
                     bbox=dict(facecolor='white', alpha=0.7, boxstyle='round'))

        # Set plot properties
        ax2.set_aspect('equal')
        ax2.set_title(f'Top {top_n} Lowest Energy Divacancies - {molecule_name}')
        ax2.set_xlabel('X (A)')
        ax2.set_ylabel('Y (A)')
        ax2.legend(loc='upper center', bbox_to_anchor=(0.5, -0.05), ncol=3)

        # Save the plot
        plt.savefig(os.path.join(results_dir, "top_divacancies.png"), dpi=300, bbox_inches='tight')
        plt.close()

        # Create Gaussian distribution plot
        fig3, ax3 = plt.subplots(figsize=(10, 6))

        # Plot histogram of formation energies
        hist, bins, _ = ax3.hist(valid_energies, bins=20, density=True, alpha=0.6, color='skyblue')

        # Plot Gaussian fit
        x = np.linspace(min_energy - 0.5, max_energy + 0.5, 1000)
        gaussian = stats.norm.pdf(x, avg_energy, std_energy)
        ax3.plot(x, gaussian, 'r-', linewidth=2, label=f'Gaussian Fit\nμ={avg_energy:.3f} eV\nσ={std_energy:.3f} eV')

        # Add lines for mean and ±1 std dev
        ax3.axvline(avg_energy, color='k', linestyle='--', alpha=0.5, label='Mean')
        ax3.axvline(avg_energy + std_energy, color='k', linestyle=':', alpha=0.5, label='+1σ')
        ax3.axvline(avg_energy - std_energy, color='k', linestyle=':', alpha=0.5, label='-1σ')

        # Set plot properties
        ax3.set_xlabel('Formation Energy (eV)')
        ax3.set_ylabel('Probability Density')
        ax3.set_title(f'Divacancy Formation Energy Distribution - {molecule_name}')
        ax3.legend()
        ax3.grid(alpha=0.3)

        # Save the distribution plot
        plt.savefig(os.path.join(results_dir, "energy_distribution.png"), dpi=300, bbox_inches='tight')
        plt.close()

        # Save distribution data for MATLAB
        with open(os.path.join(results_dir, "energy_distribution.txt"), 'w') as f:
            f.write("# Divacancy Formation Energy Distribution\n")
            f.write("# Mean: {:.6f} eV\n".format(avg_energy))
            f.write("# Std Dev: {:.6f} eV\n".format(std_energy))
            f.write("# Min: {:.6f} eV (atoms {}) \n".format(min_energy, min_pair))
            f.write("# Max: {:.6f} eV (atoms {}) \n".format(max_energy, max_pair))
            f.write("# Format: energy_value probability_density\n")
            for i in range(len(x)):
                f.write("{:.6f} {:.6f}\n".format(x[i], gaussian[i]))

        # Write summary file with statistics
        with open(os.path.join(results_dir, "summary.txt"), 'w') as f:
            f.write(f"Divacancy Formation Energy Analysis for {molecule_name}\n")
            f.write(f"----------------------------------------\n")
            f.write(f"Total divacancy pairs analyzed: {len(divacancy_pairs)}\n")
            f.write(f"Valid calculations: {len(valid_energies)}\n")
            f.write(f"Minimum formation energy: {min_energy:.3f} eV for atoms {min_pair}\n")
            f.write(f"Maximum formation energy: {max_energy:.3f} eV for atoms {max_pair}\n")
            f.write(f"Average formation energy: {avg_energy:.3f} eV\n")
            f.write(f"Standard deviation: {std_energy:.3f} eV\n")

            # List top 10 lowest formation energy sites
            f.write(f"\nTop 10 lowest formation energy divacancies (easiest to form):\n")
            for i in range(min(10, len(sorted_data))):
                (idx1, idx2), energy = sorted_data[i]
                distance = base_relaxed.get_distance(idx1, idx2)
                f.write(f"  #{i + 1} Atoms {idx1}-{idx2} (distance: {distance:.2f} A): {energy:.3f} eV\n")

            # List top 10 highest formation energy sites
            f.write(f"\nTop 10 highest formation energy divacancies (hardest to form):\n")
            for i in range(min(10, len(sorted_data))):
                (idx1, idx2), energy = sorted_data[-(i + 1)]
                distance = base_relaxed.get_distance(idx1, idx2)
                f.write(f"  #{i + 1} Atoms {idx1}-{idx2} (distance: {distance:.2f} A): {energy:.3f} eV\n")

            f.write(f"----------------------------------------\n")
    else:
        print("No valid divacancy calculations were completed.")


def _process_stw_results(results_dir, base_relaxed, bond_pairs, formation_energies, molecule_name, carbon_indices,
                         show_atom_idx=True, atom_idx_fontsize=8):
    """Process and visualize Stone-Wales results"""
    # Create a dictionary mapping bond pairs to formation energies
    energy_map = {pair: energy for pair, energy in zip(bond_pairs, formation_energies)}

    # Save formation energies with bond pairs
    np.savez(os.path.join(results_dir, "stw_energies.npz"),
             pairs=np.array(bond_pairs),
             energies=np.array(formation_energies))

    # Write energy map to text file for easy reference
    with open(os.path.join(results_dir, "energy_map.txt"), 'w') as f:
        f.write("Atom1_Index Atom2_Index Distance(A) Formation_Energy(eV)\n")
        for (idx1, idx2), energy in zip(bond_pairs, formation_energies):
            distance = base_relaxed.get_distance(idx1, idx2)
            if energy is not None:
                f.write(f"{idx1} {idx2} {distance:.3f} {energy:.3f}\n")
            else:
                f.write(f"{idx1} {idx2} {distance:.3f} None\n")

    # Filter out None values for visualization and analysis
    valid_data = [(pair, energy) for pair, energy in zip(bond_pairs, formation_energies) if energy is not None]
    if valid_data:
        valid_pairs, valid_energies = zip(*valid_data)

        # Calculate statistics
        min_energy = min(valid_energies)
        max_energy = max(valid_energies)
        min_pair = valid_pairs[valid_energies.index(min_energy)]
        max_pair = valid_pairs[valid_energies.index(max_energy)]
        avg_energy = np.mean(valid_energies)
        std_energy = np.std(valid_energies)

        # Create a custom colormap for bonds (red = high energy, blue = low energy)
        cmap = LinearSegmentedColormap.from_list("formation_energy",
                                                 ["blue", "green", "yellow", "red"])

        # Plot the structure with STW bond pairs colored by formation energy
        fig, ax = plt.subplots(figsize=(14, 12))

        # Plot all atoms first
        for i, atom in enumerate(base_relaxed):
            # Hydrogen atoms should be smaller
            marker_size = 50 if atom.symbol == 'H' else 100
            ax.scatter(atom.position[0], atom.position[1], c='lightgray', s=marker_size,
                       edgecolors='black', linewidths=1)
            # Add atom index for reference if enabled
            if show_atom_idx:
                ax.text(atom.position[0], atom.position[1], str(i), fontsize=atom_idx_fontsize)

        # Plot bonds between all carbon atoms (to show the structure)
        for idx1, idx2 in combinations(carbon_indices, 2):
            distance = base_relaxed.get_distance(idx1, idx2)
            if distance <= 1.8:  # Use standard C-C bond distance
                pos1 = base_relaxed.positions[idx1]
                pos2 = base_relaxed.positions[idx2]
                ax.plot([pos1[0], pos2[0]], [pos1[1], pos2[1]], color='lightgray',
                        linewidth=1, alpha=0.5, zorder=1)

        # Plot the STW bond pairs as colored lines
        for (idx1, idx2), energy in energy_map.items():
            if energy is not None:
                # Normalize energy for coloring
                norm_energy = (energy - min_energy) / (max_energy - min_energy) if max_energy > min_energy else 0.5
                color = cmap(norm_energy)

                # Get atom positions
                pos1 = base_relaxed.positions[idx1]
                pos2 = base_relaxed.positions[idx2]

                # Draw line between atoms
                ax.plot([pos1[0], pos2[0]], [pos1[1], pos2[1]], color=color, linewidth=3, alpha=0.8, zorder=5)

                # Mark the pair atoms
                ax.scatter([pos1[0], pos2[0]], [pos1[1], pos2[1]], c=color, s=150,
                           edgecolors='black', linewidths=1.5, zorder=10)

        # Create colorbar
        sm = plt.cm.ScalarMappable(cmap=cmap, norm=plt.Normalize(min_energy, max_energy))
        sm.set_array([])
        cbar = plt.colorbar(sm, ax=ax)
        cbar.set_label('Formation Energy (eV)')

        # Set plot properties
        ax.set_aspect('equal')
        ax.set_title(f'Stone-Wales Formation Energy Map - {molecule_name}')
        ax.set_xlabel('X (A)')
        ax.set_ylabel('Y (A)')

        # Save the plot
        plt.savefig(os.path.join(results_dir, "stw_energy_map.png"), dpi=300, bbox_inches='tight')
        plt.close()

        # Create another visualization showing the top 10 lowest energy STW defects
        fig2, ax2 = plt.subplots(figsize=(14, 12))

        # Plot all atoms first
        for i, atom in enumerate(base_relaxed):
            # Hydrogen atoms should be smaller
            marker_size = 50 if atom.symbol == 'H' else 100
            ax2.scatter(atom.position[0], atom.position[1], c='lightgray', s=marker_size,
                        edgecolors='black', linewidths=1)
            # Add atom index for reference if enabled
            if show_atom_idx:
                ax2.text(atom.position[0], atom.position[1], str(i), fontsize=atom_idx_fontsize)

        # Plot all bonds lightly
        for idx1, idx2 in combinations(carbon_indices, 2):
            distance = base_relaxed.get_distance(idx1, idx2)
            if distance <= 1.8:
                pos1 = base_relaxed.positions[idx1]
                pos2 = base_relaxed.positions[idx2]
                ax2.plot([pos1[0], pos2[0]], [pos1[1], pos2[1]], color='lightgray',
                         linewidth=1, alpha=0.5, zorder=1)

        # Sort STW defects by formation energy
        sorted_data = sorted(valid_data, key=lambda x: x[1])

        # Plot only the top 10 lowest formation energy Stone-Wales defects
        top_n = min(10, len(sorted_data))
        for i in range(top_n):
            (idx1, idx2), energy = sorted_data[i]

            # Get atom positions
            pos1 = base_relaxed.positions[idx1]
            pos2 = base_relaxed.positions[idx2]

            # Draw line between atoms with label
            line = ax2.plot([pos1[0], pos2[0]], [pos1[1], pos2[1]],
                            linewidth=4, label=f"{idx1}-{idx2}: {energy:.3f} eV")

            # Mark the pair atoms with larger markers of same color
            color = line[0].get_color()
            ax2.scatter([pos1[0], pos2[0]], [pos1[1], pos2[1]], c=color, s=150,
                        edgecolors='black', linewidths=1.5, zorder=10)

            # Add rank number at midpoint
            mid_x = (pos1[0] + pos2[0]) / 2
            mid_y = (pos1[1] + pos2[1]) / 2
            ax2.text(mid_x, mid_y, f"#{i + 1}", fontsize=12,
                     ha='center', va='center',
                     bbox=dict(facecolor='white', alpha=0.7, boxstyle='round'))

        # Set plot properties
        ax2.set_aspect('equal')
        ax2.set_title(f'Top {top_n} Lowest Energy Stone-Wales Defects - {molecule_name}')
        ax2.set_xlabel('X (A)')
        ax2.set_ylabel('Y (A)')
        ax2.legend(loc='upper center', bbox_to_anchor=(0.5, -0.05), ncol=3)

        # Save the plot
        plt.savefig(os.path.join(results_dir, "top_stw_defects.png"), dpi=300, bbox_inches='tight')
        plt.close()

        # Create Gaussian distribution plot
        fig3, ax3 = plt.subplots(figsize=(10, 6))

        # Plot histogram of formation energies
        hist, bins, _ = ax3.hist(valid_energies, bins=20, density=True, alpha=0.6, color='skyblue')

        # Plot Gaussian fit
        x = np.linspace(min_energy - 0.5, max_energy + 0.5, 1000)
        gaussian = stats.norm.pdf(x, avg_energy, std_energy)
        ax3.plot(x, gaussian, 'r-', linewidth=2, label=f'Gaussian Fit\nμ={avg_energy:.3f} eV\nσ={std_energy:.3f} eV')

        # Add lines for mean and ±1 std dev
        ax3.axvline(avg_energy, color='k', linestyle='--', alpha=0.5, label='Mean')
        ax3.axvline(avg_energy + std_energy, color='k', linestyle=':', alpha=0.5, label='+1σ')
        ax3.axvline(avg_energy - std_energy, color='k', linestyle=':', alpha=0.5, label='-1σ')

        # Set plot properties
        ax3.set_xlabel('Formation Energy (eV)')
        ax3.set_ylabel('Probability Density')
        ax3.set_title(f'Stone-Wales Formation Energy Distribution - {molecule_name}')
        ax3.legend()
        ax3.grid(alpha=0.3)

        # Save the distribution plot
        plt.savefig(os.path.join(results_dir, "energy_distribution.png"), dpi=300, bbox_inches='tight')
        plt.close()

        # Save distribution data for MATLAB
        with open(os.path.join(results_dir, "energy_distribution.txt"), 'w') as f:
            f.write("# Stone-Wales Formation Energy Distribution\n")
            f.write("# Mean: {:.6f} eV\n".format(avg_energy))
            f.write("# Std Dev: {:.6f} eV\n".format(std_energy))
            f.write("# Min: {:.6f} eV (atoms {}) \n".format(min_energy, min_pair))
            f.write("# Max: {:.6f} eV (atoms {}) \n".format(max_energy, max_pair))
            f.write("# Format: energy_value probability_density\n")
            for i in range(len(x)):
                f.write("{:.6f} {:.6f}\n".format(x[i], gaussian[i]))

        # Write summary file with statistics
        with open(os.path.join(results_dir, "summary.txt"), 'w') as f:
            f.write(f"Stone-Wales Formation Energy Analysis for {molecule_name}\n")
            f.write(f"----------------------------------------\n")
            f.write(f"Total bond pairs analyzed: {len(bond_pairs)}\n")
            f.write(f"Valid calculations: {len(valid_energies)}\n")
            f.write(f"Minimum formation energy: {min_energy:.3f} eV for bond {min_pair}\n")
            f.write(f"Maximum formation energy: {max_energy:.3f} eV for bond {max_pair}\n")
            f.write(f"Average formation energy: {avg_energy:.3f} eV\n")
            f.write(f"Standard deviation: {std_energy:.3f} eV\n")

            # List top 10 lowest formation energy sites
            f.write(f"\nTop 10 lowest formation energy Stone-Wales defects (easiest to form):\n")
            for i in range(min(10, len(sorted_data))):
                (idx1, idx2), energy = sorted_data[i]
                distance = base_relaxed.get_distance(idx1, idx2)
                f.write(f"  #{i + 1} Bond {idx1}-{idx2} (distance: {distance:.2f} A): {energy:.3f} eV\n")

            # List top 10 highest formation energy sites
            f.write(f"\nTop 10 highest formation energy Stone-Wales defects (hardest to form):\n")
            for i in range(min(10, len(sorted_data))):
                (idx1, idx2), energy = sorted_data[-(i + 1)]
                distance = base_relaxed.get_distance(idx1, idx2)
                f.write(f"  #{i + 1} Bond {idx1}-{idx2} (distance: {distance:.2f} A): {energy:.3f} eV\n")

            f.write(f"----------------------------------------\n")
    else:
        print("No valid Stone-Wales calculations were completed.")


if __name__ == "__main__":
    # Configuration - modify these values directly
    molecule_name = "GQD_HEXAGON_3_3"  # Choose which molecule to analyze (e.g., QD_4, QD_7)
    defect_type = "all"     # Choose 'vacancy', 'divacancy', 'stw', or 'all'
    show_atom_idx = True    # Set to False to hide atom indices in visualizations
    atom_idx_fontsize = 8   # Font size for atom index labels (increase for larger text)
    # Element-specific distances


    DEBUG_MODE = False    # Set to True to enable debug mode (no calculations)
    excluded_atoms = [] # List of atom indices to exclude from analysis

    if DEBUG_MODE:
        print("Debug mode enabled - no calculations will be performed")
        view(read(molecules_data[molecule_name]["path"]))
        print("Atoms loaded. You can now inspect the structure.")
        print("After inspection, you can specify atom indices to exclude from analysis.")

    else:
        target_element, _ = determine_target_element(read(molecules_data[molecule_name]["path"]))
        max_distances = {
            'C': {'div': 1.7, 'stw': 1.8},
            'Si': {'div': 2.3, 'stw': 2.6},
            'Ge': {'div': 2.5, 'stw': 2.8}
        }

        # Set distances based on target element
        div_dist = max_distances[target_element]['div']
        stw_dist = max_distances[target_element]['stw']

        # Setup calculator based on operating system
        system_platform = platform.system()

        if system_platform == 'Linux':
            # Use GPAW on Linux
            from gpaw import GPAW, PW, FermiDirac

            calc = GPAW(
                xc='PBE',
                mode=PW(300),  # Reduced from 400 - still reasonable for C-C bond breaking
                kpts=(1, 1, 1),
                symmetry='off',
                spinpol=True,  # Keep this - essential for radicals
                occupations=FermiDirac(0.05),  # Increased smearing - faster SCF convergence
                convergence={
                    'energy': 0.001,  # Relaxed from 0.0005 (1 meV is fine for formation energies)
                    'density': 1e-4,  # Much looser - 1e-6 is overkill
                    'eigenstates': 1e-6,  # Looser from 1e-8
                },
                mixer={'backend': 'pulay', 'beta': 0.1, 'nmaxold': 5, 'weight': 50},  # Faster mixing
                maxiter=300,  # Explicit limit to catch non-convergence earlier
                txt='calculation.txt',
            )
            print("Using GPAW calculator on Linux")

        elif system_platform == 'Windows':
            # Use SevenNet on Windows
            from sevenn.calculator import SevenNetCalculator

            # "mpa" refers to the MPtrj + sAlex modal, used for evaluating Matbench Discovery.
            calc = SevenNetCalculator('7net-l3i5', modal='mpa')
            print("Using SevenNet calculator on Windows")

        else:
            raise RuntimeError(f"Unsupported platform: {system_platform}. Only Linux (GPAW) and Windows (SevenNet) are supported.")

        element_mu = calculate_element_mu(calc, target_element)
        print(f"Chemical potential for {target_element}: {element_mu:.3f} eV")
        # Setup initial structure
        base_relaxed, base_energy = setup_structure(molecule_name)

        # Run selected analysis
        if defect_type == 'vacancy' or defect_type == 'all':
            analyze_vacancies(target_element, base_relaxed, base_energy, molecule_name, show_atom_idx, excluded_atoms=excluded_atoms, atom_idx_fontsize=atom_idx_fontsize)

        if defect_type == 'divacancy' or defect_type == 'all':
            analyze_divacancies(target_element, base_relaxed, base_energy, molecule_name,
                               max_distance=div_dist, show_atom_idx=show_atom_idx, excluded_atoms=excluded_atoms, atom_idx_fontsize=atom_idx_fontsize)

        if defect_type == 'stw' or defect_type == 'all':
            analyze_stone_wales(target_element, base_relaxed, base_energy, molecule_name,
                               max_distance=stw_dist, show_atom_idx=show_atom_idx, excluded_atoms=excluded_atoms, atom_idx_fontsize=atom_idx_fontsize)

        print("\nAnalysis complete!")

    